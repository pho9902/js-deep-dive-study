# 26장 ES6-함수의-추가-기능

## 함수의 구분

ES6 이전 모든 함수는 callable이면서 constructor다.

ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.
|ES6 함수의 구분| constructor | prototype | super | arguments |
| --- | --- | --- | --- | --- |
| 일반 함수 | O | O | X | O |  
| 메서드 | X | X | O | O |  
| 화살표 함수 | X | X | X | X |

## 메서드

- 메서드 축약 표현으로 정의된 함수만을 의미함
- non-constructor임
- 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.
  - 메서드가 아닌 함수는 내부 슬롯 [[HomeObject]]가 없기 때문에 super 키워드 사용 불가

## 화살표 함수

- 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안

### 화살표 함수 정의

- 함수 정의
  - 함수 표현식으로 정의해야 함
  - 호출 방식은 기존 함수와 동일
- 매개변수 선언
  - 매개변수가 여러 개인 경우 () 안에 매개변수를 선언
  - 매개변수가 한 개의 경우 () 생략 가능
  - 매개변수가 없을 경우 () 생략 불가능
- 함수 몸체 정의
  - 함수 몸체가 하나의 문으로 구성된다면 {} 생략 가능, 이때 그 문이 표현식이라면 암묵적으로 반환된다.
  - 표현식이 아닌 문이라면 {} 생략 불가능
  - 객체 리너털을 반환하는 경우 객체 리터널을 ()로 감싸 주어야 함
  - 함수 몸체가 여러 개의 문이면 {} 생략 불가능, 반환값은 명시적으로 반환해야함

### 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 non-constructor다.
2. 중복된 매개변수 이름 선언 X
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않음

### this

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라고 한다.

화살표 함수는 함수 자체의 this 바인딩을 갖지 않기 때문에 call, apply, bind 메서드를 사용해도 화살표 함수 내부의 this를 교체할 수 없다.

객체 내의 화살표 함수의 this는 상위 스코프인 전역의 this가 가르키는 전역 객체를 가르키기 때문에 메서드로 사용하는 것은 적절치 않다.

### super

super는 매서드 내에서만 사용할 수 있지만, 화살표함수는 super 바인딩을 갖지 않으므로 super를 참조해도 에러가 발생하지 않고 constructor 내부의 super 바인딩을 참조한다.

### arguments

화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않기 때문의 상위 스코프의 argument를 참조한다. 때문에 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.

## Rest 파라미터

### 기본 문법

- 함수에 전달된 인수등의 목록을 배열로 전달 받는다.
- 반드시 마지막 파라미터이어야 한다.
- 단 하나만 선언할 수 있다.
- 함수 객체의 length 프로퍼티에 영향을 주지 않음

## 매개변수 기본값

ES6에서 도입된 매개 변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소할 수 있다.  
Rest 파라미터에는 기본값을 지정할 수 없다.  
기본값은 함수 객체 length 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.
