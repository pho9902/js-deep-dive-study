# 04장 변수

### 메모리 
- 메모리 셀(1byte) 의 집합체 

- 각 셀은 고유의 메모리 주소(메모리 공간의 위치, 0부터 시작해서 메모리 크기만큼 정수로 표현)를 갖는다.

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높음(js는 개발자의 직접적인 메모리제어 허용X)

- 변수와 값이 저장된 메모리 주소의 매핑 관계 또한 메모리에 저장
    ---
    
### 변수 
- 하나의 값을 저장하기 위해 확보한 메모리 공간(을 식별하기 위해 붙인 이름)
        
- 컴파일러 or 인터프리터가 메모리 공간 주소로 치환해서 실행

- 식별자 : 변수 이름을 식별자 라고도 함, 어떤 값을 구별해서 식별할 수 있는 고유한 이름

- 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
---

### 변수 선언

- 값을 저장하기 위한 메모리 공간 확보 및 주소 연결

- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호됨

- var 의 단점과 let, const 의 도입

- 변수 선언 후 값을 할당하지 않아도 undefined 값 할당 (const는 에러남)

---

### 변수 선언의 실행 시점과 변수 호이스팅

- 변수 선언은 런타임(소스코드가 한 줄씩 순차적으로 실행) 이전 단계에서 먼저 실행 됨

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거침
    - 모든 선언문을 찾아내 먼저 실행함 (초기화X 선언)
    - 평과 과정이 끝나면 선언문을 모두 제외하고 순차적으로 실행

- 선언문이 코드의 선두로 끌어 올려진 것처럼 동작해 호이스팅이라 부름

- let/const 의 호이스팅
    - let/const 는 TDZ에 의해 선언전에 참조하려 하면 Ref에러를 뱉는다

    - 스코프에 진입 할 때 변수가 만들어지고 TDZ 가 생성된다.

    - 하지만 코드 실행이 변수가 실제 있는 위치에 도달 할 때 까지 액세스는 할 수 없다.

    - 변수가 선언된 시점에서 제어흐름이 TDZ를 떠난 상태가 되며 변수를 참조 할 수 있게 된다.

    - [참조 블로그 : let과 const는 호이스팅이 될까](https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365)

--- 

### 값의 할당, 재할당 

- 값의 할당은 선언과 달리 런타임 때 실행됨

- 할당 할 때 undefined 가 저장된 메모리공간을 비우는게 아니라 새로운 메모리 공간을 확보해서 저장함
