# 25장 클래스

## 클래스는 프로토타입의 문법적 설탕인가?

클래스는 생성자 함수와 매우 유사하게 동작하지만 다음과 같이 몇가지 차이가 있다.

1. 클래스는 new 연산자 없이 호출하면 에러가 남
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공
3. 호이스팅이 발생하지 않는 것처럼 동작
4. 클래스 내의 모든 코드는 암묵적으로 'strict mode' 적용
5. 클래스의 프로퍼티의 [[Enumerable]]의 값이 false이다.

이러한 차이점 때문에 단순한 문법적 설탕이라고 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 좋다.

## 클래스의 정의

- class 키워드를 사용하여 정의
- 파스칼 케이스를 사용(사용하지 않아도 에러는 발생하지는 않음)
- 일급 객체의 특징을 가짐
- 몸체에 constructor(생성자), 프로토타입 메서드, 정적 메서드 세 가지 정의 가능

## 클래스 호이스팅

클래스는 함수로 평가되지만 정의 이전에 참조할 수 없다. 이는 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

## 인스턴스 생성

클래스는 new 연산자와 함께 호출되어 인스턴스를 생성한다.

## 메서드

### constructor(생성자)

- constructor: 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
  - 이름 변경 불가능
  - 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
  - 인스턴스를 초기화하려면 constructor를 생략해서는 안 됨

### 프로토타입 메서드

클래스 몸체에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.

### 정적 메서드

클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드가 된다. 정적 메서드는 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 호출은 불가능 하다.

### 정적 메서드와 프로토타입 메서드의 차이

1. 각자 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스에서 호출, 포로토타입 메서드는 인스턴스로 호출
3. 정적 메서드는 인스턴스 프로퍼티 참조 X, 프로토타입 메서드는 인스턴스 프로퍼티 참조 O
4. 각자 내부의 this 바인딩이 다르다.

### 클래스에서 정의한 메서드의 특징

1. 메서드 축약 표현을 사용
2. 콤마 필요 없음
3. 암묵적으로 strict mode로 실행
4. for ... in 문이나 Object.keys 메서드 등으로 열거할 수 없다.
5. non-constructor이다.

## 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩

- new 연산자와 호출되면 constructor의 내부 코드가 실행되기 전에 암묵적으로 빈 객체 생성 -> 클래스가 생성한 인스턴스
- 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가르키는 객체 설정
- 인스턴스는 this에 바인딩

2. 인스턴스 초기화

- constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화

3. 인스턴스 반환

- 인스턴스가 바인딩된 this가 암묵적으로 반환

## 프로퍼티

### 인스턴스 프로퍼티

- 인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.
- 접근 제한자 지원 X -> 인스턴스의 프로퍼티는 언제나 public

### 접근자 프로퍼티

각각 get, set 키워드를 사용하여 getter, setter 함수를 프로토타입의 프로포티로 정의가 가능하다.

### 클래스 필드 정의 제안

- 클래스 필드는 인스턴스 프로퍼티가 되기 때문에 여기에 함수를 할당하는 것은 권장하지 않는다.

### private 필드 정의 제안

#을 붙여주면 private 필드가 된다. 참조할 때도 #을 붙여주어야 한다.

### static 필드 정의 제안

사용할 수 없었지만 TC39 프로세스의 stage 3에 제안되어 있다.

## 상속에 의한 클래스 확장

- 상속에 의한 클래스 확장: 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것

### extends 키워드

extends 키워드를 사용하여 상속받을 클래스를 정의한다. 수퍼틀래스와 서브클래스 간의 상속 관계를 설정  
클래스도 프로토타입을 통해 상속을 구현

### 동적 상속

extends 키워드는 클래스뿐만 아니라 생성자 함수도 상속 받을 수 있음, 단 extends 카워드 앞에는 반드시 클래스가 와야함  
extends 키워드 뒤에 표현식을 넣어 상속을 동적으로 결정할 수 있음

### 서브클래스의 constructor

super()는 수퍼클래스의 constructor를 호출하여 인스턴스를 생성한다.

### super 키워드

- super를 호출하면 수퍼클래스의 constructor를 호출
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있음

super를 호출할 때 주의할 사항

1. 서브클래스에서 constructor를 생략하지 않은 경우 서브클래스의 constructor에서는 반드시 super를 호출해야함
2. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없음
3. super는 반드시 서브클래스의 constructor에서만 호출한다.

### 상속 클래스의 인스턴스 생성 과정

1. 서브클래스의 super 호출
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constructor로 복귀와 this 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

### 표준 빌트인 생성자 함수 확장

extends 키워드를 사용하면 표준 빌트인 생성자 함수를 확장하여 사용이 가능해 진다.
