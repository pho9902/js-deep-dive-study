# 25장 클래스

# 25.1 클래스는 프로토타입의 문법적 설탕인가?

클래스는 프로토타입 기반 객체 지향 프로그래밍 언어인 자바스크립트에서는 반드시 필요한 기능은 아니지만 다른 클래스 기반 언어 개발자들이 쉽게 자바스크립트를 사용하게 하기 위해 개발된 기능이다. 클래스는 생성자 함수와 유사하지만 다음과 같은 차이점이 있다.

1. 클래스를 new연산자 없이 호출하면 에러가 발생한다. 생성자 함수는 new 연산자가 없이 호출 되면 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공하지만 생성자 함수는 그렇지 않다.
3. 클래스는 호이스팅이 발생하지 않는 것 처럼 동작하지만 생성자 함수는 정의 방식에 따라 변수호이스팅이나 함수 호이스팅이 발생한다.
4. 클래스 내의 모든 코드에는 암묵저으로 strict mode가 적용되어 있어 해제할 수 없다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 이 false라서 열거되지 않는다.

# 25.2 클래스 정의

클래스는 class키워드를 통해 정의한다. 함수 표현식과 같이 변수에 할당하며 선언 할 수 있다. 이 경우

```jsx
class Shcool {} //클래스 선언문

const student = class {}; // 익명 클래스 표현식
const teacher = class Job {}; // 기명 클래스 표현식
```

클래스는 변수에 할당이 가능하다. 이는 클래스가 객체와 같은 일급 객체임을 뜻한다. 자세히 들여다 보면 클래스는 함수이다. 특히 생성자 함수와 아주 유사함을 보인다.

```jsx
const Teacher = (function () {
  function Teacher(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Teacher.prototype.hello = function () {
    console.log("hello");
  };

  // 정적 메서드
  Teacher.hi = function () {
    console.log("hi");
  };

  return Teacher;
})();
```

```jsx
class Classroom {
  constructor(name) {
    this.name = name;
  }

  start() {
    console.log("수업 시작");
  }

  static end() {
    console.log("수업끝");
  }
}
```

# 25.3 클래스 호이스팅

클래스 선언문으로 정의한 클래스는 소스코드 평가과정 즉 런타임 이전에 평가되어 함수 객체를 생성한다. 이와 동시에 프로토타입 또한 생성된다. 클래스는 let,const로 선언한 변수와 같이 호이스팅 된다. 즉 TDZ가 존재한다.

# 25.4 인스턴스 생성

클래스는 생성자 함수이며 new연산자와 함께 호출하여 인스턴스를 생성한다. new연산자가 없어도 오류가 발생한다거나 하진 않지만 new연산자가 없이 호출하면 인스턴스를 생성하지 않는 일반 함수로서 호출되는 것이기에 사용하지 않는다.

# 25.5 메서드

### 25.5.1 constructor

constructor는 인스턴스를 생성하고 초기화하기 위한 메서드 이며 이름을 변경 할 수 없다.

프로토타입의 constructor메서드는 프로토타입의 생성자 함수를 가리키는 프로퍼티이며 클래스의 constructor메서드와는 관계가 없다.

constructor는 클래스 내에 하나만 존재 가능하다. 만일 constructor가 생략된다면 빈 객체를 생성한다,

### 25.5.2 프로토타입 메서드

클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

이렇듯 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 매커니즘이다.

### 25.5.3 정적 메서드

정적 메서드란 인스턴스를 생성하지 않아도 호출 할 수 있는 메서드를 뜻한다.

클래스에서 정적 메서드를 선언하려면 static키워드를 붙이면 된다.

클래스는 평가 후에 함수 객체로 평가되기 때문에 인스턴스의 프로토타입 체인 상에 존재하지 않는다. 때문에 인스턴스로 클래스의 메서드를 상속 받을 수 없다.

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

### 25.5.5 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 달리 클래스에 메서드를 정의 할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode로 실행된다.
4. for…in문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]값이 false이다.
5. 내부 메서드 [[Construct]]를 갖지 않는 non-constructor이다. 따라서 new 연산자와 함께 호출 할 수 없다.

# 25.6 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩

클래스가 new연산자와 함께 호출되면 암묵적으로 빈 객체가 생성된다. 이 때 클래스가 생성한 인스턴스의 프로토타입은 클래스의 prototype프로퍼티가 가리키는 객체이다. ㄱ,리고 생성된 객체에 this가 바인딩된다.

1. 인스턴스 초기화

constructor 내부 코드가 실행되어 this에 바인딩된 객체를 초기화 한다.

1. 인스턴스 반환

클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this에 암묵적으로 반환된다.

# 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.

constructor 내부에서 정의한 프로퍼티는 this에 바인딩된 클래스가 생성 할 인스턴스에 추가된다.

### 25.7.2 접근자 프로퍼티

접근자 프로퍼티는 자체적인 값을 가지지 않고 다른 데이터 프로퍼티값을 참조한다.

접근자 프로퍼티는 다른 값을 참조하는 getter함수와 다른 값을 저장하는 setter함수로 나뉜다.

getter함수는 다른 값을 취득하여 사용되기 때문에 무언가를 반환 해주어야 한다.

setter함수는 무언가를 프로퍼티에 할당해야 할 때 사용되기 때문에 반드시 매개변수를 가져야 한다. setter함수는 한번에 하나의 값만 할당 받기 때문에 단 하나의 매개변수를 갖는다.

클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.

# 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.

생성자 함수와 달리 클래스의 상속은 extends 키워드로 간편히 가능 하다.

### 25.8.2 extends 키워드

클래스의 상속 관계에 있어 상위클래스를 수퍼 클래스라 하고 하위 클래스를 서브 클래스라고 한다.

extends키워드는 두 클래스 간의 상속 관계를 정의한다.

수퍼 클래스와 서브클래스는 인스턴스의 프로토타입 체인 뿐 아니라 클래스 간의 프로토타입 체인도 생성한다.

### 25.8.3 동적 상속

extends 키워드 앞에는 반드시 클래스가 와야 한다.

extends 키워드로 클래스가 아닌 생성자 함수를 상속 받을 수 있다. 정확히는 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가 될 수 있는 모든 표현식이 가능 하다. 이를 통해 동적으로 상속 받을 대상을 결정 할 수 있다.

### 25.8.4. 서브클래스의 constructor

수퍼 클래스의 내부에서 constructor를 생략한다면 빈 객체가 생성된다. 그리고 서브클래스에서 constructor를 생략하면 마찬가지로 빈 객체가 생성되지만 상속 관계는 명시된다.

### 25.8.5 super 키워드

super키워드를 호출하면 수퍼 클래스의 constructor를 호출한다.

super키워드를 참조하면 수퍼클래스의 메서드를 호출 할 수 있다.

### 25.8.6 상속 클래스의 인스턴스 생성 과정

1. 서브클래스의 super호출

자바스크립트 엔진이 클래스를 평가할 때 수퍼 클래스와 서브 클래스의 구분을 위해[[ConstructorKind]] 내부 슬롯을 가진다. 이 값이 base 혹은 derived 인지 에 따라 동작을 달리한다. 다른 클래스를 상속 받지 않는 클래스는 평가 과정에서 빈 인스턴스를 생성하고 this에 바인딩 한다.

서브클래스의 경우에는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이 때문에 서브클래스의 constructor에 super 키워드를 호출해야 하는 것이다.

1. 수퍼클래스의 인스턴스 생성과 this 바인딩

수퍼 클래스의 경우 빈 객체를 생서하고 이를 this에 바인딩한다.

서브클래스일 경우 인스턴스는 수퍼 클래스가 생성하지만 인스턴스의 프로토타입은 서브클래스의 프로토타입이다. 또한 인스턴스는 서브클래스가 생성한 것으로 처리된다.

1. 수퍼클래스의 인스턴스 초기화

수퍼 클래스의 cosntructor대로 this에 바인딩된 인스턴스를 초기화한다.

1. 서브클래스 constructor로의 복귀와 this 바인딩

super의 호출이 끝나고 super가 반화환한 인스턴스에 서브클래스의 this를 바인딩 한다. 이 때문에 서브 클래스의 constructor에서 super호출이 없으면 바인딩할 인스턴스가 없기 때문에 반드시 super가 있어야 한다.

1. 서브클래스의 인스턴스 초기와

상속 받은 프로퍼티는 두고 서브 클래스의 constructor 대로 인스턴스를 초기화 한다.

1. 인스턴스 반환

완성된 인스턴스가 반환된다.
