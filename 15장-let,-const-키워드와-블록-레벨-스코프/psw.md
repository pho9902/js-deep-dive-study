# 15장 let,const 키워드와 블록 레벨 스코프

## 본문 요약

# 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

var 키워드로 변수를 선언하게 되면 그 후에 다시 var키워드로 중복 선언하게 될 시 앞선 선언을 덮어씌워 버린다. 만일 초기화문이 없는 선언문이라면 무시된다. 이는 개발자의 의도치 않은 중복 선언을 잡아내지 못하고 먼저 선언된 변수를 사용하지 못하게 만들 수 있다.

### 15.1.2 함수 레벨 스코프

```jsx
var i = 0;

if (true) {
  var i = 1;
}
console.log(i); // 1
```

함수 내부에서 전역에 존재하는 변수의 값을 변경시킨다.

### 15.1.3 변수 호이스팅

var 키워드로 선언된 변수는 실행 전 호이스팅 되어 선언 전에 참조 할 수 있다. 이 때 값은 undefined로 출력 되어 의도치 않은 동작을 초래 할 수 있다.

# 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

let 키워드는 var키워드와 달리 중복 선언 시 문법 오류를 반환한다.

### 15.2.2 블록 레벨 스코프

let 키워드로 선언된 변수는 블록 레벨 스코프를 따른다.

```jsx
let n = 11;
function f() {
  let n = 1;
  let m = 2;
  console.log(n); // 1
}
f();
console.log(n); // 11
console.log(m); // m is not defined
```

n의 경우 함수 내부에서는 1로 반환 되지만 스코프가 끝난 이후에는 전역에서 선언된 11로 반환된다. m의 경우 함수 내부에서 선언되고 함수 밖에서 참조하려 하니 오류를 반환한다.

### 15.2.3 변수 호이스팅

let 키워드로 선언된 변수는 호이스팅이 발생하지 않는 듯 보인다.

```jsx
console.log(n); // Cannot access 'n' before initialization
let n;
console.log(n); // undefined
n = 1;
console.log(n); // 1
```

예제를 보면 변수 선언 이전엔 초기화 전엔 접근 할 수 없다는 에러가 발생하고 선언 후에는 undefined가 반환되며 할당 후에는 값이 반환된다. 이처럼 스코프가 시작되어 초기화가 시작되는 지점 사이를 일시적 사각지대(TDZ)라고 부른다. 이처럼 let은 선언 전에는 참조 할 수가 없음으로 호이스팅이 발생하지 않는 듯 보인다. 하지만 참조 에러가 아닌 초기화전 접근 제한 에러가 발생하는 것을 보면 호이스팅이 발생하기는 한다.

# 15.3 const 키워드

### 15.3.1 선언과 초기화

const 키워드로 변수를 선언 할 시에는 선언과 초기화가 동시에 이루어져야만 한다.

```jsx
const name = "sun"; // 동시에 이루어 지지 않는다면 에러를 반환한다.
```

### 15.3.2 재할당 금지 / 15.3.3 상수

const로 선언한 변수는 상수로서 재할당이 되지 않는다.

### 15.3.4 const 키워드와 객체

const 키워드로 선언한 변수에 객체를 할당 한다면 그 변수의 프로퍼티는 수정이 가능하다. 원시 타입과 달리 객체타입은 메모리 주소의 변경 없이 수정이 가능하기 때문이다.

const는 재할당을 금지할 뿐 불변을 의미하진 않는다.

# 15.4 var VS let VS const

- var는 사용하지 않고
- 재할당이 필요한 경우에만 스코프를 최대한 좁게하여 let을 쓰고
- 가능하면 const를 쓴다.
