# 15장 let,-const-키워드와-블록-레벨-스코프

## 15.1 var 키워드로 선언한 변수의 문제점

1. 변수 중복선언 허용
2. 함수레벨 스코프 (`let`, `const` 키워드는 블록레벨 스코프를 가진다.)
3. 변수 호이스팅

## 15.2 let 키워드

> `var` 키워드이 단점을 보완하기 위해 `ES6` 에서 `let` 과 `const` 키워드가 새롭게 등장했다.

### 15.2.3 변수 호이스팅

`let` 키워드로 선언한 변수는 `var` 키워드와 달리 `선언단계` 와 `초기화 단계` 분리되어 진행된다.

### 15.2.4 전역 객체와 let

`var` 키워드로 선언한 전역변수는 `globalThis` 에 할당되지만 `let` 이나 `const` 키워드로 선언한 변수는 globalThis 가 아닌 전역 렉시컬 환경의 선언적 환경 레코드에 할당된다.

## 15.3 const 키워드

> `const` 키워드는 상수를 선언하기 위해 사용된다. 여기서 말하는 상수는 식별자에 저장되는 값이 아닌 식별자가 가리키는 메모리주소를 의미한다. 즉 재할당이 불가능하다.

### 15.3.1 선언과 초기화

`const` 키워드는 재할당이 불가능하기에 반드시 선언과 동시에 초기화해야한다. 그렇지 않다면 syntax error 가 발생한다.

```js
const foo = 1;

const bar; // SyntaxError: Missing initializer in const declaration
```

### 15.3.3 상수

`const` 키워드는 재할당이 불가능하기에 원시 값을 할당한 경우 값을 변경할 수 없다.
이러한 특징을 이용해 특정 고정값을 관리할 때 용이하게 쓰인다.

```js
// 완전한 상수(어플리케이션 실행도중 어떤 상황이든 같은 값을 가지는 값)은 관습적으로 UPPER_SNAKE_CASE 를 사용해 선언한다.
const TAX_RATE = 0.1;
```

### 15.3.4 const 키워드와 객체

`const` 키워드는 재할당이 불가능하지 값이 불변한건 아니다 따라서 객체(object, array) 등은 재할당이 아니라도 property 나 element 를 변경할 수 있다.

```js
const person = {
  name: 'lee',
};

person.name = '이석호';

const personNames = ['이석호'];
personNames[0] = 'lsh';
```

## 15.4 var vs. let vs. const

> 예상치못한 에러를 발생시키지 않으려면 변수를 선언할 때 아래 규칙을 지키는 습관을 가지는게 좋다.

1. `ES6` 이상이라면 `var` 키워드를 사용하지 않는다.
2. 재할당이 필요한 경우에만 `let` 키워드를 사용하고 `const` 키워드 사용을 지향해야한다.
3. `scope` 범위는 최대한 좁게 만든다.

이러한 규칙을 지킨다면 최대한 작은 scope 내에서 우선적으로 `const` 로 선언한 뒤 필요할 때 `let` 으로 바꿔도 늦지 않는다.
