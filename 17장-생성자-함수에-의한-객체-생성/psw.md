# 17장 생성자 함수에 의한 객체 생성

# 17.1 Object 생성자 함수

new연산자와 Object 생성자 함수를 호출하면 빈 객체가 생성된다.

```jsx
const obj = new Object();
// obj ={};
```

# 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식

객체 리터럴에 의한 객체의 생성은 직관적이며 편하지만 동일한 프로퍼티를 갖는 여러 개의 객체를 생성할 때 불편함을 겪는다.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

객체 리터럴과 반대로 같은 프로퍼티를 갖는 여러 개의 객체를 생성할 때 편하다.

```jsx
function person(age) {
  this.age = age;
}

const jane = new person(12);
console.log(jane); // {age : 12
const park = new person(23);
console.log(park); // {age : 23}
```

### 17.2.3 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩 : 암묵저인 빈 객체를 생성하고 이 빈 객체는 this에 바인딩 된다. 이 과정은 런타임 이전에 실행된다.
2. 인스턴스 초기화 : 생성자 함수의 코드가 실행하여 바인딩된 인스턴스에 프로퍼티나 메서드를 하나씩 추가한다.
3. 인스턴스 반환 : 생성자 함수 내부의 머든 처리가 완료된 후 바인딩된 인스턴스를 반환한다.

### 17.2.4 내부 메서드 [[Call]] 과 [[Construct]]

함수도 객체이기에 내부 메서드를 갖는다. 그 중 [[Call]] 과 [[Construct]]는 함수 객체만 갖는 특수한 내부 메서드이다. 함수는 다른 일반 객체와 달리 호출이 가능하다. 호츨 될 때 사용 되는게 [[Call]] 메서드이다. [[Construct]] 메서드는 new연산자와 함께 생성자 함수로서 호출 될 때 사용된다.

두 메서드는 일반 객체에는 없고 함수 객체에만 존재한다.

### 17.2.5 constructor 와non-constructor의 구분

- constructor : 함수 선언문 ,함수 표현식, 클래스(클래스도 함수)
- non-constructor : 화살표 함수,메서드

constructor 와 non-constructor의 차이는 생성자 함수로서 new연산자와 함께 호출 하였을 때 작동을 하느냐 하지 않느냐의 차이이다. non-constructor함수를 생성자 함수로서 사용하면 오류를 반환한다.

ES6에서 정의된 메서드의 정의와 일반적으로 알고 있는 메서드의 정의는 약간 차이가 있는데 일반적으로 객체의 프로퍼티로 함수가 들어가면 메서드라고 알고 있으나 ES6에선 메서드의 축약 표현만을 메서드로 정의한다.

### 17.2.6 new 연산자

함수가 리턴값으로 객체를 반환 할 경우 new연산자와 함께 호출하여 새 객체를 생성 하는 연산을 할 수 있다. 만일 함수가 객체를 반환하지 않는다면 new연산자는 빈 객체를 반환한다.
