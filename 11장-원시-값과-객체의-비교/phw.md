# 11장 원시-값과-객체의-비교

자바스크립트가 제공하는 7가지 데이터 타입은 원시타입과 객체타입으로 구분 할 수 있다.

1. 원시타입 : 변경 불가능한 값

   - 변수에 할당하면 변수에는 실제 값이 저장된다.
   - 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨 (값에 의한 전달)
   - 상대적으로 메모리를 적게 씀

1. 객체(참조)타입 : 변경 가능한 값

   - 변수에 할당하면 변수에는 참조 값이 저장된다.
   - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨 (참조에 의한 전달)
   - 경우에 따라 메모리 소비가 큼

## 원시 값

- [변경 불가능 하다](#11장-원시-값과-객체의-비교)는 것은 변수가 아니라 값에 대한 진술이다.
  - 변수는 재할당을 퉁해 언제든 변경(교체) 할 수 있기 때문
  - 변수가 참조하는 메모리공간의 주소가 변경되는 이유는 변수에 할당된 원시값이 변경불가이기 때문

## 객체

- 객체 자체의 재할당 없이 직접 변경할 수 있다
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근 할 수 있다.

  - 참조값 : 생성된 객체가 저장된 메모리 공간의 주소 그 자체

- 객체를 변경할때마다 원시값처럼 이전 값을 복사해서 새롭게 생성하지 않는 이유

  1. 원시값 처럼 크기가 일정하지않음

  1. 크기가 매우 클 수도 있음

  1. 프로퍼티 값이 객체일 수도 있어 복사 생성 비용이 많이듬

  1. 이러한 이유들로 메모리의 효율적 소비가 어렵고 성능이 나빠짐

- [구조적인 단점(여러개의 식별자가 하나의 객체를 공유할 수 있음)](#값에의한-전달-참조에-의한-전달)을 감안한 설계

## 값에의한 전달, 참조에 의한 전달

- 값에의한 전달 예제

```js
let score = 90;
let copy = score;

console.log(score, copy); // => 90 90

score = 100;

console.log(score, copy); // => 100 90
```

- score 와 copy는 서로 다른 메모리 주소를 가지고 있기 때문에 서로 간섭할 수 없다.

- 참조에 의한 전달 예제

```js
const person = {
  name: "Park",
};

const copy = person; // 두개의 식별자가 하나의 객체를 공유

copy.adress = "seoul";

console.log(person); // => {name:"Park", adress:"seoul"}
```

- 하나의 객체를 공유하기때문에 객체를 변경하면 서로 영향이 있다.

## 얕은 복사, 깊은 복사

- 얕은 복사 : 한단계까지만 복사하는 것
  - 객체의 복사로 할당된 변수도 얕은 복사라고 부름
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사하는 것
  - 원시값의 복사로 할당된 변수도 깊은 복사라고 부름
